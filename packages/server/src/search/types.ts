import type { Entity, Status, EntityType } from '@backlog-mcp/shared';

/**
 * Resource document for search indexing
 */
export interface Resource {
  id: string;      // MCP URI: mcp://backlog/resources/path/to/file.md
  path: string;    // Relative path: resources/path/to/file.md
  title: string;   // First # heading or filename
  content: string; // Full markdown content
}

/**
 * Document types that can be searched
 */
export type SearchableType = 'task' | 'epic' | 'resource';

/**
 * Search filter options
 */
export interface SearchFilters {
  status?: Status[];
  type?: EntityType;
  epic_id?: string;
  parent_id?: string;
}

/**
 * Search configuration options
 */
export interface SearchOptions {
  filters?: SearchFilters;
  limit?: number;
  /** Field name -> boost factor (e.g., { title: 2 }) */
  boost?: Record<string, number>;
  /** Filter by document types */
  docTypes?: SearchableType[];
  /** Sort mode: 'relevant' (default) or 'recent' */
  sort?: 'relevant' | 'recent';
}

/**
 * A single search result with relevance score
 */
export interface SearchResult {
  id: string;
  score: number;
  task: Entity;
}

/**
 * Resource search result
 */
export interface ResourceSearchResult {
  id: string;
  score: number;
  resource: Resource;
}

/**
 * Server-side snippet: a plain-text excerpt showing where the query matched.
 * Generated by the search service so both MCP tools and HTTP endpoints
 * return consistent match context. (ADR-0073)
 */
export interface SearchSnippet {
  /** Which field the snippet came from (e.g. 'title', 'description', 'content') */
  field: string;
  /** Plain-text excerpt with the match in context (~120 chars) */
  text: string;
  /** All fields that contained a match */
  matched_fields: string[];
}

/**
 * Unified search result with proper types for the /search API.
 * Separates the item from metadata (score, type) for type safety.
 */
export interface UnifiedSearchResult {
  item: Entity | Resource;
  score: number;
  type: SearchableType;
  /** Server-side snippet. Present when the search service generates it. */
  snippet?: SearchSnippet;
}

/**
 * Abstract search service interface.
 * Implementations can use Orama, MiniSearch, Elasticsearch, etc.
 */
export interface SearchService {
  /** Build/rebuild index from tasks */
  index(tasks: Entity[]): Promise<void>;

  /** Search tasks by query string */
  search(query: string, options?: SearchOptions): Promise<SearchResult[]>;

  /** Add single document to index */
  addDocument(task: Entity): Promise<void>;

  /** Remove document from index */
  removeDocument(id: string): Promise<void>;

  /** Update document in index */
  updateDocument(task: Entity): Promise<void>;
}
